<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>シンプルなリズムゲーム</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
body {
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
height: 100vh;
margin: 0;
background-color: #1a1a1a;
color: #ffffff;
font-family: 'Inter', sans-serif;
overflow: hidden;
user-select: none;
-webkit-user-select: none;
touch-action: none;
}
#game-container {
position: relative;
display: flex;
flex-direction: column;
align-items: center;
width: 100%;
max-width: 500px;
height: 80vh;
max-height: 800px;
border: 2px solid #555;
border-radius: 12px;
box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
background-color: #222;
}
#gameCanvas {
width: 100%;
height: 100%;
border-radius: 10px;
background-color: #333;
}
#ui-overlay {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
display: flex;
flex-direction: column;
justify-content: space-between;
align-items: center;
padding: 20px;
box-sizing: border-box;
}
#quit-button {
position: absolute;
top: 10px;
left: 10px;
padding: 8px 16px;
font-size: 1em;
background-color: #ff5555;
color: #fff;
border: none;
border-radius: 6px;
cursor: pointer;
box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
transition: background-color 0.1s;
z-index: 100;
}
#quit-button:hover {
background-color: #ff3333;
}
#score-display {
font-size: 2.5em;
font-weight: bold;
text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}
#combo-display {
font-size: 1.5em;
font-weight: bold;
color: #ffcc00;
text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
}
.score-combo-container {
display: flex;
flex-direction: column;
align-items: center;
}
#hit-message {
font-size: 3em;
font-weight: bold;
text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
animation: fade-out 0.5s forwards;
opacity: 0;
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
pointer-events: none;
}
@keyframes fade-out {
from { opacity: 1; transform: translate(-50%, -50%) scale(1); }
to { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
}
#start-screen {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.7);
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
z-index: 10;
border-radius: 12px;
padding: 20px;
box-sizing: border-box;
text-align: center;
overflow-y: auto;
}
#start-screen h2 {
font-size: 2em;
margin-bottom: 20px;
color: #fff;
}
.difficulty-buttons {
display: flex;
flex-wrap: wrap;
justify-content: center;
gap: 15px;
padding: 10px;
}
.difficulty-button {
padding: 15px 30px;
font-size: 1.2em;
font-weight: bold;
color: #fff;
border: none;
border-radius: 8px;
cursor: pointer;
box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
transition: transform 0.1s, box-shadow 0.1s;
}
#easy-button {
background-color: #4CAF50;
}
#easy-button:hover {
background-color: #45a049;
}
#hard-button {
background-color: #FFC107;
}
#hard-button:hover {
background-color: #ffb300;
}
#expert-button {
background-color: #F44336;
}
#expert-button:hover {
background-color: #d32f2f;
}
.score-info, .rules-info, .color-selector {
width: 100%;
max-width: 400px;
margin-top: 20px;
background-color: rgba(255, 255, 255, 0.1);
border-radius: 8px;
padding: 15px;
box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
text-align: left;
}
.score-info h3, .rules-info h3, .color-selector h3 {
font-size: 1.2em;
margin-top: 0;
border-bottom: 1px solid rgba(255, 255, 255, 0.3);
padding-bottom: 5px;
margin-bottom: 10px;
}
.score-info p, .rules-info p {
margin: 5px 0;
}
.color-selector {
display: flex;
flex-direction: column;
align-items: center;
}
.color-selector label {
margin-bottom: 10px;
}
@media (max-width: 600px) {
.difficulty-button {
width: 100%;
}
}
</style>
</head>
<body>
<div id="game-container">
<canvas id="gameCanvas"></canvas>
<div id="ui-overlay">
<button id="quit-button" style="display: none;">終了</button>
<div class="score-combo-container">
<div id="score-display">スコア: 0</div>
<div id="combo-display"></div>
</div>
<div id="hit-message"></div>
</div>
<div id="start-screen">
<h2>難易度を選んでください</h2>
<div class="score-info">
<h3 id="high-score-title">ハイスコア</h3>
<p id="high-score">0</p>
</div>
<div class="difficulty-buttons">
<button id="easy-button" class="difficulty-button">easy</button>
<button id="hard-button" class="difficulty-button">hard</button>
<button id="expert-button" class="difficulty-button">expert</button>
</div>
<div class="color-selector">
<h3>ノーツの色</h3>
<label for="note-color">色を選択してください</label>
<input type="color" id="note-color" value="#ff007f">
</div>
<div class="rules-info">
<h3>スコアと判定</h3>
<p>PERFECT: 100点</p>
<p>GREAT: 50点</p>
<p>GOOD: 20点</p>
<p>ミス: 0点</p>
<p>コンボが続くと得点アップ！</p>
</div>
</div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const gameContainer = document.getElementById('game-container');
const scoreDisplay = document.getElementById('score-display');
const comboDisplay = document.getElementById('combo-display');
const hitMessageEl = document.getElementById('hit-message');
const startScreen = document.getElementById('start-screen');
const easyButton = document.getElementById('easy-button');
const hardButton = document.getElementById('hard-button');
const expertButton = document.getElementById('expert-button');
const highScoreEl = document.getElementById('high-score');
const quitButton = document.getElementById('quit-button');
const noteColorInput = document.getElementById('note-color');

// Web Audio APIの変数
let audioContext = null;
let isAudioReady = false;

// ゲーム変数
let gameStarted = false;
let score = 0;
let combo = 0;
let noteSpeed;
let noteGenerationInterval;
let chordProbability;
const hitTolerance = 40; // ノーツを叩く判定の許容範囲（ピクセル）
let laneWidth;
const noteSize = 40;
const hitLineYOffset = 100;
let notesToGenerateIntervalId;
let currentNoteColor = noteColorInput.value;

let activeNotes = [];
let lastFrameTime = 0;
let activeTapLanes = [false, false, false, false];
let animationFrameId;

// 難易度設定
const difficulties = {
// easy難易度をさらに簡単に調整し、コードノーツの出現率を0に設定
easy: { noteSpeed: 0.2, noteGenerationInterval: 1.0, chordProbability: 0 },
hard: { noteSpeed: 0.5, noteGenerationInterval: 0.5, chordProbability: 0.2 },
expert: { noteSpeed: 0.7, noteGenerationInterval: 0.3, chordProbability: 0.3 },
};

// コンテナに合わせてキャンバスのサイズを変更
const resizeCanvas = () => {
canvas.width = gameContainer.offsetWidth;
canvas.height = gameContainer.offsetHeight;
laneWidth = canvas.width / 4;
};

// Web Audio APIを初期化し、ブラウザの自動再生ポリシーを解除する
const setupAudio = () => {
if (isAudioReady) return;
try {
// AudioContextを初期化
audioContext = new (window.AudioContext || window.webkitAudioContext)();
isAudioReady = true;
// ノーツ音をテスト再生して、ブラウザの制限を解除
playNoteSound(880, 0.01);
} catch (e) {
console.error('Web Audio API is not supported in this browser.', e);
}
};

// Web Audio APIを使って簡単な打鍵音を再生する
const playNoteSound = (frequency = 440, duration = 0.05) => {
if (!isAudioReady || !audioContext) return;

const oscillator = audioContext.createOscillator();
const gainNode = audioContext.createGain();

oscillator.connect(gainNode);
gainNode.connect(audioContext.destination);

// 音の設定: 「タンタン」のイメージに合わせて矩形波 (square) を使用
oscillator.type = 'square';

oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

// クリックノイズを防ぐため、ゲインを急激に上げ下げする
gainNode.gain.setValueAtTime(0, audioContext.currentTime);
// 立ち上がり
gainNode.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.005);
// 減衰
gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);

oscillator.start(audioContext.currentTime);
oscillator.stop(audioContext.currentTime + duration);
};

// イベントリスナーの設定
const setupEventListeners = () => {
easyButton.addEventListener('click', () => startGame('easy'));
hardButton.addEventListener('click', () => startGame('hard'));
expertButton.addEventListener('click', () => startGame('expert'));
quitButton.addEventListener('click', endGame);
window.addEventListener('resize', resizeCanvas);
// タッチをより確実にキャッチするためにコンテナで入力をリッスン
gameContainer.addEventListener('mousedown', handleInput);
gameContainer.addEventListener('touchstart', handleInput, { passive: false });
gameContainer.addEventListener('mouseup', handleInputEnd);
gameContainer.addEventListener('touchend', handleInputEnd);
gameContainer.addEventListener('mouseout', handleInputEnd);
window.addEventListener('keydown', handleKeyboardInput);
window.addEventListener('keyup', handleKeyboardInputEnd);
noteColorInput.addEventListener('input', (event) => {
currentNoteColor = event.target.value;
});
};

const startGame = (difficulty) => {
// 難易度ボタンのクリックでAudioContextを初期化
setupAudio();

noteSpeed = difficulties[difficulty].noteSpeed;
noteGenerationInterval = difficulties[difficulty].noteGenerationInterval;
chordProbability = difficulties[difficulty].chordProbability;

// インターバルベースのランダムノート生成を設定
if (notesToGenerateIntervalId) {
clearInterval(notesToGenerateIntervalId);
}
notesToGenerateIntervalId = setInterval(generateRandomNote, noteGenerationInterval * 1000);

startGameLogic();
};

const startGameLogic = () => {
gameStarted = true;
startScreen.style.display = 'none';
quitButton.style.display = 'block';

score = 0;
combo = 0;
activeNotes = [];
updateScoreDisplay();
updateComboDisplay();

lastFrameTime = performance.now();

if (animationFrameId) {
cancelAnimationFrame(animationFrameId);
}

animationFrameId = requestAnimationFrame(gameLoop);
};

const endGame = () => {
gameStarted = false;
saveHighScore();
startScreen.style.display = 'flex';
quitButton.style.display = 'none';

cancelAnimationFrame(animationFrameId);
clearInterval(notesToGenerateIntervalId);
};

const gameLoop = (timestamp) => {
if (!gameStarted) {
return;
}

const deltaTime = (timestamp - lastFrameTime) / 1000;
lastFrameTime = timestamp;

update(deltaTime);
draw();

animationFrameId = requestAnimationFrame(gameLoop);
};

const generateRandomNote = () => {
// ノーツの初期位置をより高く設定
const initialY = -200;

const rand = Math.random();
if (rand < chordProbability) {
const chordLanes = [];
const numLanes = Math.random() < 0.5 ? 3 : 4;
const allLanes = [0, 1, 2, 3];
while (chordLanes.length < numLanes) {
const randomLane = allLanes[Math.floor(Math.random() * allLanes.length)];
if (!chordLanes.includes(randomLane)) {
chordLanes.push(randomLane);
}
}
chordLanes.sort((a, b) => a - b);
activeNotes.push({
type: 'chord',
lanes: chordLanes,
y: initialY,
hit: false,
missed: false,
});
} else {
activeNotes.push({
type: 'single',
lane: Math.floor(Math.random() * 4),
y: initialY,
hit: false,
missed: false,
});
}
};

const update = (deltaTime) => {
// ノーツの位置を更新
activeNotes.forEach(note => {
note.y += noteSpeed * 1000 * deltaTime;
});

// ミスしたノーツをチェック
activeNotes = activeNotes.filter(note => {
// ヒットラインを通過したノーツをチェック
if (note.y > canvas.height + noteSize) {
if (!note.missed) {
handleMiss();
}
return false; // ミスしたノーツを削除
}
return true;
});
};

const draw = () => {
// キャンバスをクリア
ctx.clearRect(0, 0, canvas.width, canvas.height);

// レーンを描画
ctx.strokeStyle = '#555';
ctx.lineWidth = 1;
for (let i = 1; i < 4; i++) {
ctx.beginPath();
ctx.moveTo(i * laneWidth, 0);
ctx.lineTo(i * laneWidth, canvas.height);
ctx.stroke();
}

// ノーツを描画
ctx.fillStyle = currentNoteColor;
// ノーツの高さを noteSize に変更
const noteHeight = noteSize;
activeNotes.forEach(note => {
if (note.type === 'single') {
// ノーツは横長の長方形 (幅: noteSize * 3, 高さ: noteSize)
const noteX = note.lane * laneWidth + laneWidth / 2 - noteSize * 1.5;
const noteY = note.y - noteHeight / 2;
ctx.fillRect(noteX, noteY, noteSize * 3, noteHeight);
} else if (note.type === 'chord') {
note.lanes.forEach(lane => {
const noteX = lane * laneWidth + laneWidth / 2 - noteSize * 1.5;
const noteY = note.y - noteHeight / 2;
ctx.fillRect(noteX, noteY, noteSize * 3, noteHeight);
});
}
});

// 判定ラインを描画
const hitLineY = canvas.height - hitLineYOffset;
ctx.strokeStyle = '#00ccff';
ctx.lineWidth = 4;
ctx.beginPath();
ctx.moveTo(0, hitLineY);
ctx.lineTo(canvas.width, hitLineY);
ctx.stroke();

// フィードバック付きのタップターゲットを描画
ctx.lineWidth = 1;
for (let i = 0; i < 4; i++) {
const alpha = activeTapLanes[i] ? 0.7 : 0.2;
ctx.fillStyle = `rgba(0, 204, 255, ${alpha})`;
ctx.fillRect(i * laneWidth, hitLineY, laneWidth, canvas.height - hitLineY);
}
};

const handleInput = (event) => {
if (event.target.id === 'quit-button') return;
if (!gameStarted) return;
event.preventDefault();

const rect = gameContainer.getBoundingClientRect();
const hitLineY = canvas.height - hitLineYOffset;

const touches = event.touches || [event];
for (let i = 0; i < touches.length; i++) {
const touch = touches[i];
const x = touch.clientX - rect.left;
const lane = Math.floor(x / laneWidth);
if (lane >= 0 && lane < 4) {
activeTapLanes[lane] = true;
}
}

// mousedown/touchstart でシングル/コードノーツのヒットをチェック
for (let j = activeNotes.length - 1; j >= 0; j--) {
const note = activeNotes[j];
if (note.type === 'single' && activeTapLanes[note.lane]) {
const distFromHitLine = Math.abs(note.y - hitLineY);
if (distFromHitLine <= hitTolerance) {
handleHit(note, distFromHitLine);
activeNotes.splice(j, 1);
}
} else if (note.type === 'chord') {
const allLanesTapped = note.lanes.every(lane => activeTapLanes[lane]);
const distFromHitLine = Math.abs(note.y - hitLineY);

if (allLanesTapped && distFromHitLine <= hitTolerance) {
handleHit(note, distFromHitLine);
activeNotes.splice(j, 1);
}
}
}
};

const handleInputEnd = (event) => {
if (event.target.id === 'quit-button') return;
if (!gameStarted) return;
const rect = gameContainer.getBoundingClientRect();
const touches = event.changedTouches || [event];
for (let i = 0; i < touches.length; i++) {
const touch = touches[i];
const x = touch.clientX - rect.left;
const lane = Math.floor(x / laneWidth);
if (lane >= 0 && lane < 4) {
activeTapLanes[lane] = false;
}
}
};

const handleKeyboardInput = (event) => {
if (!gameStarted) return;
const key = event.key.toLowerCase();
const keyMap = { 'a': 0, 's': 1, 'd': 2, 'f': 3 };
const lane = keyMap[key];
if (lane !== undefined) {
activeTapLanes[lane] = true;

const hitLineY = canvas.height - hitLineYOffset;

// シングルノーツのヒットをチェック
for (let i = activeNotes.length - 1; i >= 0; i--) {
const note = activeNotes[i];
if (note.type === 'single' && note.lane === lane) {
const distFromHitLine = Math.abs(note.y - hitLineY);
if (distFromHitLine <= hitTolerance) {
handleHit(note, distFromHitLine);
activeNotes.splice(i, 1);
}
} else if (note.type === 'chord' && note.lanes.includes(lane)) {
const allLanesTapped = note.lanes.every(l => activeTapLanes[l]);
const distFromHitLine = Math.abs(note.y - hitLineY);

if (allLanesTapped && distFromHitLine <= hitTolerance) {
handleHit(note, distFromHitLine);
activeNotes.splice(i, 1);
}
}
}
}
};

const handleKeyboardInputEnd = (event) => {
const key = event.key.toLowerCase();
const keyMap = { 'a': 0, 's': 1, 'd': 2, 'f': 3 };
const lane = keyMap[key];
if (lane !== undefined) {
activeTapLanes[lane] = false;
}
};

const handleHit = (note, distance) => {
let points = 0;
let message = '';
let noteFrequency = 440; // 基本の音程

if (distance < 10) {
points = 100;
message = 'PERFECT!';
hitMessageEl.style.color = '#00ff00';
} else if (distance < 20) {
points = 50;
message = 'GREAT!';
hitMessageEl.style.color = '#ffff00';
} else {
points = 20;
message = 'GOOD!';
hitMessageEl.style.color = '#ffa500';
}

if (note.type === 'chord') {
score += points * note.lanes.length;
combo += note.lanes.length;
noteFrequency = 550; // コードノーツは少し高い音
} else {
score += points;
combo++;
noteFrequency = 440 + note.lane * 20; // レーンごとにわずかに音程を変える
}

// ヒット時に音を鳴らす
playNoteSound(noteFrequency);

updateScoreDisplay();
updateComboDisplay();
showMessage(message);
};

const handleMiss = () => {
combo = 0;
updateComboDisplay();
showMessage('MISS!', '#ff0000');
};

const updateScoreDisplay = () => {
scoreDisplay.textContent = `スコア: ${score}`;
};

const updateComboDisplay = () => {
comboDisplay.textContent = combo > 0 ? `${combo} コンボ` : '';
};

const showMessage = (text, color = 'white') => {
hitMessageEl.textContent = text;
hitMessageEl.style.color = color;
hitMessageEl.style.opacity = 1;
hitMessageEl.style.animation = 'none'; // Reset animation
setTimeout(() => {
hitMessageEl.style.animation = 'fade-out 0.5s forwards';
}, 10);
};

const loadHighScore = () => {
const highscore = localStorage.getItem('rhythmGameHighScore') || 0;
highScoreEl.textContent = highscore;
};

const saveHighScore = () => {
const highscore = localStorage.getItem('rhythmGameHighScore') || 0;
if (score > parseInt(highscore)) {
localStorage.setItem('rhythmGameHighScore', score);
}
loadHighScore();
};

// 初期設定
resizeCanvas();
setupEventListeners();
loadHighScore(); // ページ読み込み時にハイスコアをロード
});
</script>
</body>
</html>